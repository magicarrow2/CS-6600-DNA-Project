<!doctype html>
<!-- The Time Machine GitHub pages theme was designed and developed by Jon Rohan, on Feb 7, 2012. -->
<!-- Follow him for fun. http://twitter.com/jonrohan. Tail his code on https://github.com/jonrohan -->
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <link rel="stylesheet" href="stylesheets/stylesheet.css" media="screen">
  <link rel="stylesheet" href="stylesheets/github-dark.css">
  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>                                                                                                        
  <script type="text/javascript" src="javascripts/script.js"></script>

  <title>CS 6600 DNA Computing Project</title>
  <meta name="description" content="This is a project for an Intelligent Systems class which demonstrates the utility of using hill-climbing algorithms for turning a 3-SAT equation into a set of DNA strands for a DNA computer.">                                                                                          

  <meta name="viewport" content="width=device-width,initial-scale=1">

</head>

<body>

  <div class="wrapper">
    <header>
      <h1 class="title">CS 6600 DNA Computing Project</h1>
    </header>
    <div id="container">
      <p class="tagline">This is a project for an Intelligent Systems class which demonstrates the utility of using hill-climbing algorithms for turning a 3-SAT equation into a set of DNA strands for a DNA computer.</p>                                                                                                   
      <div id="main" role="main">
        <div class="download-bar">
        <div class="inner">
          <a href="https://github.com/magicarrow2/CS-6600-DNA-Project/tarball/master" class="download-button tar"><span>Download</span></a>                                                                              
          <a href="https://github.com/magicarrow2/CS-6600-DNA-Project/zipball/master" class="download-button zip"><span>Download</span></a>                                                                              
          <a href="https://github.com/magicarrow2/CS-6600-DNA-Project" class="code">View CS 6600 DNA Computing Project on GitHub</a>                                                                                     
        </div>
        <span class="blc"></span><span class="trc"></span>
        </div>
        <article class="markdown-body">
          <h3>
<a id="word-of-caution" class="anchor" href="#word-of-caution" aria-hidden="true"><span class="octicon octicon-link"></span></a>Word of Caution</h3>

<p>This software will only run on in Linux.</p>

<h3>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction</h3>

<p>Boolean satisfiability problems are known for being among the first problems to be defined as NP-complete.  In 2002, Ravinderjit S. Braich, Nickolas Chelyapov, Cliff Johnson, Paul W. K. Rothemund, and Leonard Adleman solved a <a href="http://www.sciencemag.org/content/296/5567/499.abstract">20-Variable 3-SAT problem using a DNA computer</a>.  This computer used massive parallelism made possible through DNA computing to search all 2^20 possible solutions to find the one correct solution in a non-exponential number of steps.  The software in this GitHub project is designed to come up with a set of DNA strands that can be used in a DNA computer similar to theirs.</p>

<h3>
<a id="problem-description" class="anchor" href="#problem-description" aria-hidden="true"><span class="octicon octicon-link"></span></a>Problem Description</h3>


<p>The goal of the project is to determine the utility of using a hill climbing algorithm to design DNA sequences useful for creating a DNA computer.  The project will compare the performance of three different hill-climbing variants: a regular hill-climber with mutation, a hill-climber with simulated annealing and mutation, and a "relaxed greediness" hill-climber of my own invention.</p>

<p>The goal of the code is to input a 3-SAT problem and output a set of DNA strands that can represent the true and false states of each of the unique variables in the 3-SAT problem.  This requires a search in a combinatorial search space.  In order to create such a library of DNA strands, the DNA strands have to meet certain requirements:</p>

<ul>
<li>Each variable in the 3-SAT problem will be represented by a unique pair of unique DNA sequences: one of the pair represents False, the other represents True.</li>
<li>Each unique DNA strand in the library must not bind to itself.</li>
<li>Each unique DNA strand in the library must not bind to other strands in the library.</li>
</ul>

<h3>
<a id="why-it-matters" class="anchor" href="#why-it-matters" aria-hidden="true"><span class="octicon octicon-link"></span></a>Why It Matters</h3>

<p>This project is important because there are many cases in DNA computing besides this one where DNA strands that have the above mentioned properties are desirable.  In order to represent a concept using a DNA strand, that DNA strand has to be unique, stable, and combine predictably.  Other DNA computers such as ones using toe-hold mediated strand displacement must have DNA strands with these properties.  Unexpected side reactions can easily break a DNA computer.  The self-assembly attribute of DNA strands is what makes DNA computing work, but it is simultaneously what makes the design of such computers hard.</p>

<p>DNA computer design requires multiple searches in combinatorial solution space.  This requires efficient algorithms to be able to search the space, or an analytic method of solving the problem directly without searching.  Since an analytic method does not yet exist for DNA computer strand design, we must resort to searching.

<h3>
<a id="demonstration" class="anchor" href="#demonstration" aria-hidden="true"><span class="octicon octicon-link"></span></a>Demonstration</h3>

<p>We begin with creating an input file.  The 3-SAT file contains a 3-SAT equation in Conjunctive Normal Form (CNF).</p> 

<p><img src="https://raw.githubusercontent.com/magicarrow2/CS-6600-DNA-Project/gh-pages/images/Big%20Input%20File.jpeg" alt="big input file"></p>

<p>To make this work, the compiled jar file must be located in the same folder that the nupack4.0.3 folder is in.  The program is run with "java -jar StickerModelJava.jar".  The system then launches a GUI wherein the user may enter the name of the input file, select an algorithm, and choose an output filename.  The user also has the option of selecting the number of nucleotides in each DNA strand (all strands are the same length).  There is a field labeled "Iteration Limit" where the user may choose how long he or she wants the program to search.  If the user wants to let the program run indefinitely he or she should enter a negative number.</p>

<p><img src="https://raw.githubusercontent.com/magicarrow2/CS-6600-DNA-Project/gh-pages/images/DNA%20Compiler%20GUI.jpeg" alt="gui"></p>

<p>After pressing "Run", the program will run for some time.  As the program runs, the user can see algorithm working as values update in the MFE and Stats windows.  When the program is finished, the results will be displayed on the screen and written to the output file that the user specified as seen below.</p>

<p><img src="https://raw.githubusercontent.com/magicarrow2/CS-6600-DNA-Project/gh-pages/images/Big%20Output%20File.jpeg" alt="big output file"></p>

<p>The full process can be seen in the short video below (sorry, no audio).</p>

<p><iframe width="420" height="315" src="https://www.youtube.com/embed/WSjGlEYZ9zY" frameborder="0" allowfullscreen></iframe></p>

<p>Those who desire to try it for themselves can download the code from <a href="https://github.com/magicarrow2/CS-6600-DNA-Project">GitHub</a>.  The "test.txt" and "bigTest.txt" 3-SAT input files are included in the repository to give the user test examples.  The code was built using Netbeans 8 and a compiled binary has been included as well.  The nupack4.0.3 folder must be in the same directory as the  JAR binary for the program to work.</p>

<h3>
<a id="how-it-works" class="anchor" href="#how-it-works" aria-hidden="true"><span class="octicon octicon-link"></span></a>How It Works</h3>

<p>The program begins with the user specifying an input file that contains a 3-SAT boolean equation.  The program then parses the equation to extract the number of unique variables contained in the equation.  The program then creates a randomly generated set of DNA strands that is twice the size of the variable set.  Half of the strands represent the true state of the variables, the other half represents the false state.</p>

<p>Ideally, the program would check the minimum free energy structure of all possible circular permutations of DNA strand combinations.  Unfortunately, that would be extremely computationally expensive for large sets of DNA strands.  To simplify the calculations for the purposes of this experiment, only one permutation was used.  This permutation contains all of the strands in the set.  The program optimizes that permutation to be as straight and non-hybridizing as possible.</p>

<p>The program utilizes a DNA analytics software package from NuPack.org to find the minimum free energy (MFE) and structure of the strand permutation.  The structure is given in dot-parens form.  The hill climber portion of the code consists of selecting the strand with the most hybridizing nucleotides, randomly selecting one of its hybridizing nucleotides, then randomly changing it to be a new nucleotide.  The DNA strands consist entirely of adenine(A), cytosine(C), and thymine(T).</p>

<p>There is also a random chance of replacing the whole strand with a new random strand instead of just changing the one nucleotide.  This is a mutation method to help prevent getting "stuck" in a local minima.  A little experimentation found that a probability of mutation equal to 1 divided by the number of DNA strands worked well, so it was used in all three algorithms.  The score of a solution is determined by counting the number of hybridizing nucleotides in the whole DNA strand set.</p>

<p>All three algorithms are hill-climbers, but they each have unique rules for moving to a new node in the search space.  The vanilla hill-climber accepts new versions of the DNA strand set only if they have a lower score.  The hill-climber with simulated annealing accepts worse scores with a decaying probability.  The hill-climber with "relaxed greediness" accepts all new DNA strand sets regardless of the score.  This last algorithm could be considered a type of control because it tests how well the strand/nucleotide substitution part of the algorithm finds a good solution by itself.  Since changing one nucleotide can drastically change the shape of the whole structure, it can make the solution better or worse.  It's a bit like a game of whack-a-mole, but the general trend should be towards improvement.</p>

<p>It may be worth noting that in all of the algorithms, if duplicate strands appear in a new solution, one of the duplicates is replaced with a randomly generated strand.
</p>

<h3>
<a id="acknowledgements" class="anchor" href="#acknowledgements" aria-hidden="true"><span class="octicon octicon-link"></span></a>Acknowledgements</h3>

<p>This project was started as a project for a CS6600 Intelligent Systems class.  The application incorporates calls to the <a href="http://www.nupack.org/">NuPack DNA analytics software</a>.</p>

        </article>
      </div>
    </div>
    <footer>
      <div class="owner">
      <p><a href="https://github.com/magicarrow2" class="avatar"><img src="https://avatars3.githubusercontent.com/u/10986729?v=3&amp;s=60" width="48" height="48"></a> <a href="https://github.com/magicarrow2">magicarrow2</a> maintains <a href="https://github.com/magicarrow2/CS-6600-DNA-Project">CS 6600 DNA Computing Project</a></p>


      </div>
      <div class="creds">
        <small>This page generated using <a href="https://pages.github.com/">GitHub Pages</a><br>theme by <a href="https://twitter.com/jonrohan/">Jon Rohan</a></small>
      </div>
    </footer>
  </div>
  <div class="current-section">
    <a href="#top">Scroll to top</a>
    <a href="https://github.com/magicarrow2/CS-6600-DNA-Project/tarball/master" class="tar">tar</a><a href="https://github.com/magicarrow2/CS-6600-DNA-Project/zipball/master" class="zip">zip</a><a href="" class="code">source code</a>
    <p class="name"></p>
  </div>


  
  </body>
</html>
