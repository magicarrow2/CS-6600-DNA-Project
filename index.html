<!doctype html>
<!-- The Time Machine GitHub pages theme was designed and developed by Jon Rohan, on Feb 7, 2012. -->
<!-- Follow him for fun. http://twitter.com/jonrohan. Tail his code on https://github.com/jonrohan -->
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <link rel="stylesheet" href="stylesheets/stylesheet.css" media="screen">
  <link rel="stylesheet" href="stylesheets/github-dark.css">
  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>                                                                                                        
  <script type="text/javascript" src="javascripts/script.js"></script>

  <title>CS 6600 DNA Computing Project</title>
  <meta name="description" content="This is a project which demonstrates the utility of using hill-climbing algorithms for designing DNA computers.">                                                                                          

  <meta name="viewport" content="width=device-width,initial-scale=1">

</head>

<body>

  <div class="wrapper">
    <header>
      <h1 class="title">CS 6600 DNA Computing Project</h1>
    </header>
    <div id="container">
      <p class="tagline">This is a project which demonstrates the utility of using hill-climbing algorithms for designing DNA computers.</p>                                                                                                   
      <div id="main" role="main">
        <div class="download-bar">
        <div class="inner">
          <a href="https://github.com/magicarrow2/CS-6600-DNA-Project/tarball/master" class="download-button tar"><span>Download</span></a>                                                                              
          <a href="https://github.com/magicarrow2/CS-6600-DNA-Project/zipball/master" class="download-button zip"><span>Download</span></a>                                                                              
          <a href="https://github.com/magicarrow2/CS-6600-DNA-Project" class="code">View CS 6600 DNA Computing Project on GitHub</a>                                                                                     
        </div>
        <span class="blc"></span><span class="trc"></span>
        </div>
        <article class="markdown-body">
        
<h3>
<a id="word-of-caution" class="anchor" href="#word-of-caution" aria-hidden="true"><span class="octicon octicon-link"></span></a>Word of Caution</h3>

<p>This software will only run in Linux.</p>


<h3>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction</h3>

<p>DNA computing is a budding field of research.  DNA computers are able to take advantage of massive parallelism to solve complex problems quickly.  However, one of the challenges in DNA computing is the complexity of designing DNA computers.  Sometimes the analysis required to design a DNA computer is more complex than the problem being solved by the computer.  Fortunately, the solution space in DNA computer design is usually not sparce.  Usually, when given a set of DNA design constraints, there are many acceptable solutions.  The purpose of this project is to evaluate the effectiveness of hill-climbing algorithms find those solutions.</p>

<p>The example case in this project will be to find a set of DNA strands that can be used in a 3-SAT solver.  Boolean satisfiability problems are known for being among the first problems to be defined as NP-complete.  In 2002, Ravinderjit S. Braich, Nickolas Chelyapov, Cliff Johnson, Paul W. K. Rothemund, and Leonard Adleman solved a <a href="http://www.sciencemag.org/content/296/5567/499.abstract">20-Variable 3-SAT problem using a DNA computer</a>.  This computer used massive parallelism made possible through DNA computing to simultaneously search all 2^20 possible solutions to find the one correct solution.  The software in this GitHub project is designed to come up with a set of DNA strands that can be used in a DNA computer similar to theirs.</p>


<h3>
<a id="problem-description" class="anchor" href="#problem-description" aria-hidden="true"><span class="octicon octicon-link"></span></a>Problem Description</h3>

<p>The problem this project seeks to explore is finding an efficient way to design DNA computers.  This project particularly explores the utility of using hill-climbing and hill-climbing with simulated annealing as useful algorithms for completing this task.  The project compares the performance of three different hill-climbing variants: a regular hill-climber with mutation, a hill-climber with simulated annealing and mutation, and a "relaxed greediness" hill-climber of my own invention. These are used in a code which inputs a 3-SAT problem and outputs a set of DNA strands that can represent the true and false states of each of the unique variables in the 3-SAT problem.  This requires a search in a combinatorial search space.  In order to create such a library of DNA strands, the DNA strands have to meet certain requirements:</p>

<ul>
<li>Each variable in the 3-SAT problem will be represented by a unique pair of unique DNA sequences: one of the pair represents False, the other represents True.</li>
<li>Each unique DNA strand in the library must not bind to itself.</li>
<li>Each unique DNA strand in the library must not bind to other strands in the library.</li>
</ul>


<h3>
<a id="why-it-matters" class="anchor" href="#why-it-matters" aria-hidden="true"><span class="octicon octicon-link"></span></a>Why It Matters</h3>

<p>This project is important because there are many cases in DNA computing besides this one where DNA strands that have the above mentioned properties are desirable.  In order to represent a concept using a DNA strand, that DNA strand has to be unique, stable, and combine predictably.  Other DNA computers such as ones using toe-hold mediated strand displacement must have DNA strands with these properties.  Unexpected side reactions can easily break a DNA computer.  The self-assembly attribute of DNA strands is what makes DNA computing work, but it is simultaneously what makes the design of such computers hard.</p>

<p>DNA computer design requires multiple searches in combinatorial solution space.  This requires efficient algorithms to be able to search the space, or an analytic method of solving the problem directly without searching.  Since an analytic method does not yet exist for DNA computer strand design, we must resort to searching.


<h3>
<a id="demonstration" class="anchor" href="#demonstration" aria-hidden="true"><span class="octicon octicon-link"></span></a>Demonstration</h3>

<p>We begin with creating an input file.  The 3-SAT file contains a 3-SAT equation in Conjunctive Normal Form (CNF).</p> 

<figure>
<img src="https://raw.githubusercontent.com/magicarrow2/CS-6600-DNA-Project/gh-pages/images/Big%20Input%20File.jpeg" alt="Missing image for Figure 1.  CNF format file contains something like this: (x v x y) ^ (~x v ~x v y) ^ (~x v ~y v ~y)">
<figcaption>Figure 1: Example Input File</figcaption></figure>

<p>To make this work, the compiled jar file must be located in the same folder that the nupack4.0.3 folder is in.  The program is run with "java -jar StickerModelJava.jar".  The system then launches a GUI wherein the user may enter the name of the input file, select an algorithm, and choose an output filename.  The user also has the option of selecting the number of nucleotides in each DNA strand (all strands are the same length).  There is a field labeled "Iteration Limit" where the user may choose how long he or she wants the program to search.  If the user wants to let the program run indefinitely he or she should enter a negative number.</p>

<figure>
<img src="https://raw.githubusercontent.com/magicarrow2/CS-6600-DNA-Project/gh-pages/images/DNA%20Compiler%20GUI.jpeg" alt="Missing GUI image for Figure 2.">
<figcaption>Figure 2: Hill climbing application</figcaption></figure>

<p>After pressing "Run", the program will run for some time.  As the program runs, the user can see algorithm working as values update in the MFE and Stats windows.  When the program is finished, the results will be displayed on the screen and written to the output file that the user specified as seen below.</p>

<figure>
<img src="https://raw.githubusercontent.com/magicarrow2/CS-6600-DNA-Project/gh-pages/images/Big%20Output%20File.jpeg" alt="Missing image of output file for Figure 3.">
<figcaption>Figure 3: Example output file</figcaption></figure>

<p>The full process can be seen in the short video below (sorry, no audio).</p>

<figure>
<iframe width="420" height="315" src="https://www.youtube.com/embed/WSjGlEYZ9zY" frameborder="0" allowfullscreen></iframe>
<figcaption>Video 1: Demonstration of all three algorithms on a 2-variable equation</figcaption></figure>

<p>Those who desire to try it for themselves can download the code from <a href="https://github.com/magicarrow2/CS-6600-DNA-Project">GitHub</a>.  The "test.txt" and "bigTest.txt" 3-SAT input files are included in the repository to give the user test examples.  The code was built using Netbeans 8 and a compiled binary has been included as well.  The nupack4.0.3 folder must be in the same directory as the JAR binary for the program to work.</p>


<h3>
<a id="how-it-works" class="anchor" href="#how-it-works" aria-hidden="true"><span class="octicon octicon-link"></span></a>How It Works</h3>

<p>The program begins with the user specifying an input file that contains a 3-SAT boolean equation.  The program then parses the equation to extract the number of unique variables contained in the equation.  The program then creates a randomly generated set of DNA strands that is twice the size of the variable set.  Half of the strands represent the true state of the variables, the other half represents the false state.</p>

<p>Ideally, the program would check the minimum free energy structure of all possible circular permutations of DNA strand combinations.  Unfortunately, that would be extremely computationally expensive for large sets of DNA strands.  To simplify the calculations for the purposes of this experiment, only one permutation was used.  This permutation contains all of the strands in the set.  The program optimizes that permutation to be as straight and non-hybridizing as possible.</p>

<p>The program utilizes a DNA analytics software package from NuPack.org to find the minimum free energy (MFE) and structure of the strand permutation.  The structure is given in dot-parens form.  The hill climber portion of the code consists of selecting the strand with the most hybridizing nucleotides, randomly selecting one of its hybridizing nucleotides, then randomly changing it to be a new nucleotide.  The DNA strands consist entirely of adenine(A), cytosine(C), and thymine(T).</p>

<p>There is also a random chance of replacing the whole strand with a new random strand instead of just changing the one nucleotide.  This is a mutation method to help prevent getting "stuck" in a local minima.  A little experimentation found that a probability of mutation equal to 1 divided by the number of DNA strands worked well, so it was used in all three algorithms.  The score of a solution is determined by counting the number of hybridizing nucleotides in the whole DNA strand set.</p>

<p>All three algorithms are hill-climbers, but they each have unique rules for moving to a new node in the search space.  The vanilla hill-climber accepts new versions of the DNA strand set only if they have a lower score.  The hill-climber with simulated annealing accepts worse scores with a decaying probability.  The hill-climber with "relaxed greediness" accepts all new DNA strand sets regardless of the score.  This last algorithm could be considered a type of control because it tests how well the strand/nucleotide substitution part of the algorithm finds a good solution by itself.  Since changing one nucleotide can drastically change the shape of the whole structure, it can make the solution better or worse.  It's a bit like a game of whack-a-mole, but the general trend should be towards improvement.</p>

<p>The cooling schedule for the simulated annealing is chosen for each run by assuming an average change of 2 defects per iteration and back calculating start and end temperatures using start and end rejection probabilities of 0.9 and 0.1, respectively.  To find this, the following equation is used: T=-C/ln(P) where 'T' is temperature, 'P' is probability, and 'C' is the heat constant (which is equal to 2 in this case).
</p>

<p>The heat capacity in the probability equation is also based on a 2 defect change per iteration.  The probability equation used is: P=e^(-2/(T_0*e^(-C*t))) where 'T_0' is the initial temperature, 't' is the current iteration, 'C' is the heat constant (which is equal to 2 in this case), and 'P' is the probability.
</p>

<p>It may be worth noting that in all of the algorithms, if duplicate strands appear in a new solution, one of the duplicates is replaced with a randomly generated strand.  It is also worth noting that it is possible for the DNA strands to become completely "disjoint".  When this happens, the NuPack software returns with errors complaining about disjoint strands and gives empty result files.  When this occurs, I assume it to mean there are 0 defects, which I take to mean a true solution is found and the program exits.</p>


<h3>
<a id="results" class="anchor" href="#results" aria-hidden="true"><span class="octicon octicon-link"></span></a>Results</h3>

<p>After running several tests with each of the three hill-climbing algorithms, the algorithm with relaxed greediness and the algorithm with simulated annealing performed about the same with the relaxed greedy algorithm having an inconclusive lead.  The vanilla hill-climber performed the worst by a wide margin.  The vanilla hill-climber had a high tendency to get stuck on local a local minimum and stop progressing.</p>

<p>Figure 4 shows the percentage of hybridizing nucleotides for each of the algorithms when given a 10-variable problem with 15-nucleotide strands and a limit of 150 iterations.  With a problem set that size, each iteration takes about a full second.</p>

<figure>
<img src="https://raw.githubusercontent.com/magicarrow2/CS-6600-DNA-Project/gh-pages/images/Percentage%20of%20Defective%20Nucleotides.png" alt="Missing figure 4: Percentage of defective nucleotides">
<figcaption>Figure 4: Percentage of Defective Nucleotides</figcaption></figure>

<p>Figure 5 shows the number of iterations required before the program exits when given a 2-variable problem with 15-nucleotide strands and a limit of 250 iterations.  The vanilla hill-climber would get stuck and never exited while the other two quickly reached a disjoint solution.  This 2-variable problem can be seen in Video 1.</p>

<figure>
<img src="https://raw.githubusercontent.com/magicarrow2/CS-6600-DNA-Project/gh-pages/images/Number%20of%20Iterations%20Till%20Exit.png" alt="Missing figure 5: Iterations to exit">
<figcaption>Figure 5: Number of Iterations to Exit</figcaption></figure>


<h3>
<a id="conclusions" class="anchor" href="#conclusions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Conclusions</h3>

<p>The poor performance of the vanilla hill-climber seems to be directly tied to the fact that there are many unique solutions with the same score.  This creates a sort of "local minimum" in the search space which is actually a wide plateau where the neighboring solutions are neither better or worse.  Since the nearest neighbors can't improve the solution, the algorithm gets stuck.  One way to alleviate this may include changing the scoring function to try to maximize the minimum free energy (MFE) of the DNA set instead of minimizing the number of defects.  This would increase the resolution of the scoring function because several DNA sets with the same number of defects have differing MFEs.  Another possible improvement might be to have the algorithm accept new solutions that have the same score instead of only accepting better ones.  This would allow the algorithm to "slide around" the plateau with hopes of sliding off.</p>

<p>In conclusion, hill-climbing methods can be very effective in DNA computer design as long as they have some sort of annealing or mutation property.  Greedy algorithms perform horribly as there are many local minima and plateaus in the solution space.</p>


<h3>
<a id="future-work" class="anchor" href="#future-work" aria-hidden="true"><span class="octicon octicon-link"></span></a>Future Work</h3>

<p>There is a fair amount of research to be done in the area of DNA computing.  For example, there is work in the area of toe-hold mediated strand replacement where this strand design methodology could be used.  There is room for exploration with other algorithms for doing the DNA strand design.  One idea might be using a neural network to find a solution more quickly by taking advantage of its pattern recognition capabilities.</p>


<h3>
<a id="acknowledgements" class="anchor" href="#acknowledgements" aria-hidden="true"><span class="octicon octicon-link"></span></a>Acknowledgements</h3>

<p>This project was started as a project for a CS6600 Intelligent Systems class.  The application incorporates calls to the <a href="http://www.nupack.org/">NuPack DNA analytics software</a>.</p>

        </article>
      </div>
    </div>
    <footer>
      <div class="owner">
      <p><a href="https://github.com/magicarrow2" class="avatar"><img src="https://avatars3.githubusercontent.com/u/10986729?v=3&amp;s=60" width="48" height="48"></a> <a href="https://github.com/magicarrow2">magicarrow2</a> maintains <a href="https://github.com/magicarrow2/CS-6600-DNA-Project">CS 6600 DNA Computing Project</a></p>


      </div>
      <div class="creds">
        <small>This page generated using <a href="https://pages.github.com/">GitHub Pages</a><br>theme by <a href="https://twitter.com/jonrohan/">Jon Rohan</a></small>
      </div>
    </footer>
  </div>
  <div class="current-section">
    <a href="#top">Scroll to top</a>
    <a href="https://github.com/magicarrow2/CS-6600-DNA-Project/tarball/master" class="tar">tar</a><a href="https://github.com/magicarrow2/CS-6600-DNA-Project/zipball/master" class="zip">zip</a><a href="" class="code">source code</a>
    <p class="name"></p>
  </div>


  
  </body>
</html>
